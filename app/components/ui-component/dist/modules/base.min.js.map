{"version":3,"sources":["base/base.js"],"names":["angular","module","factory","$compile","compile","element","link","isFunction","post","compiledContents","contents","remove","pre","scope","clone","append","apply","arguments","$document","$window","getStyle","el","cssprop","currentStyle","getComputedStyle","style","isStaticPositioned","parentOffsetEl","docDomEl","offsetParent","position","elBCR","this","offset","offsetParentBCR","top","left","offsetParentEl","clientTop","scrollTop","clientLeft","scrollLeft","boundingClientRect","getBoundingClientRect","width","prop","height","pageYOffset","documentElement","pageXOffset","positionElements","hostEl","targetEl","positionStr","appendToBody","hostElPos","targetElWidth","targetElHeight","targetElPos","positionStrParts","split","pos0","pos1","shiftWidth","center","right","shiftHeight","bottom","hoverEventSyncer","duration","clear","close","closed","closedTimer","register","timer","func","clearTimeout","setTimeout","msec","newInstance","directive","restrict","template","attrs","text"],"mappings":"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","file":"base.min.js","sourcesContent":["angular.module('ui-component.base').factory('RecursionHelper', ['$compile', function($compile){\n    return {\n        /**\n         * Manually compiles the element, fixing the recursion loop.\n         * @param element\n         * @param [link] A post-link function, or an object with function(s) registered via pre and post properties.\n         * @returns An object containing the linking functions.\n         */\n        compile: function(element, link){\n            // Normalize the link parameter\n            if(angular.isFunction(link)){\n                link = { post: link };\n            }\n\n            // Break the recursion loop by removing the contents\n            var contents = element.contents().remove();\n            var compiledContents;\n            return {\n                pre: (link && link.pre) ? link.pre : null,\n                /**\n                 * Compiles and re-adds the contents\n                 */\n                post: function(scope, element){\n                    // Compile the contents\n                    if(!compiledContents){\n                        compiledContents = $compile(contents);\n                    }\n                    // Re-add the compiled contents to the element\n                    compiledContents(scope, function(clone){\n                        element.append(clone);\n                    });\n\n                    // Call the post-linking function, if any\n                    if(link && link.post){\n                        link.post.apply(null, arguments);\n                    }\n                }\n            };\n        }\n    };\n}]);\n\nangular.module('ui-component.base').factory('$position', ['$document', '$window', function ($document, $window) {\n\n    function getStyle(el, cssprop) {\n      if (el.currentStyle) { //IE\n        return el.currentStyle[cssprop];\n      } else if ($window.getComputedStyle) {\n        return $window.getComputedStyle(el)[cssprop];\n      }\n      // finally try and get inline style\n      return el.style[cssprop];\n    }\n\n    /**\n     * Checks if a given element is statically positioned\n     * @param element - raw DOM element\n     */\n    function isStaticPositioned(element) {\n      return (getStyle(element, 'position') || 'static' ) === 'static';\n    }\n\n    /**\n     * returns the closest, non-statically positioned parentOffset of a given element\n     * @param element\n     */\n    var parentOffsetEl = function (element) {\n      var docDomEl = $document[0];\n      var offsetParent = element.offsetParent || docDomEl;\n      while (offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent) ) {\n        offsetParent = offsetParent.offsetParent;\n      }\n      return offsetParent || docDomEl;\n    };\n\n    return {\n      /**\n       * Provides read-only equivalent of jQuery's position function:\n       * http://api.jquery.com/position/\n       */\n      position: function (element) {\n        var elBCR = this.offset(element);\n        var offsetParentBCR = { top: 0, left: 0 };\n        var offsetParentEl = parentOffsetEl(element[0]);\n        if (offsetParentEl != $document[0]) {\n          offsetParentBCR = this.offset(angular.element(offsetParentEl));\n          offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;\n          offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;\n        }\n\n        var boundingClientRect = element[0].getBoundingClientRect();\n        return {\n          width: boundingClientRect.width || element.prop('offsetWidth'),\n          height: boundingClientRect.height || element.prop('offsetHeight'),\n          top: elBCR.top - offsetParentBCR.top,\n          left: elBCR.left - offsetParentBCR.left\n        };\n      },\n\n      /**\n       * Provides read-only equivalent of jQuery's offset function:\n       * http://api.jquery.com/offset/\n       */\n      offset: function (element) {\n        var boundingClientRect = element[0].getBoundingClientRect();\n        return {\n          width: boundingClientRect.width || element.prop('offsetWidth'),\n          height: boundingClientRect.height || element.prop('offsetHeight'),\n          top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),\n          left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)\n        };\n      },\n\n      /**\n       * Provides coordinates for the targetEl in relation to hostEl\n       */\n      positionElements: function (hostEl, targetEl, positionStr, appendToBody) {\n\n        var positionStrParts = positionStr.split('-');\n        var pos0 = positionStrParts[0], pos1 = positionStrParts[1] || 'center';\n\n        var hostElPos,\n          targetElWidth,\n          targetElHeight,\n          targetElPos;\n\n        hostElPos = appendToBody ? this.offset(hostEl) : this.position(hostEl);\n\n        targetElWidth = targetEl.prop('offsetWidth');\n        targetElHeight = targetEl.prop('offsetHeight');\n\n        var shiftWidth = {\n          center: function () {\n            return hostElPos.left + hostElPos.width / 2 - targetElWidth / 2;\n          },\n          left: function () {\n            return hostElPos.left;\n          },\n          right: function () {\n            return hostElPos.left + hostElPos.width;\n          }\n        };\n\n        var shiftHeight = {\n          center: function () {\n            return hostElPos.top + hostElPos.height / 2 - targetElHeight / 2;\n          },\n          top: function () {\n            return hostElPos.top;\n          },\n          bottom: function () {\n            return hostElPos.top + hostElPos.height;\n          }\n        };\n\n        switch (pos0) {\n          case 'right':\n            targetElPos = {\n              top: shiftHeight[pos1](),\n              left: shiftWidth[pos0]()\n            };\n            break;\n          case 'left':\n            targetElPos = {\n              top: shiftHeight[pos1](),\n              left: hostElPos.left - targetElWidth\n            };\n            break;\n          case 'bottom':\n            targetElPos = {\n              top: shiftHeight[pos0](),\n              left: shiftWidth[pos1]()\n            };\n            break;\n          default:\n            targetElPos = {\n              top: hostElPos.top - targetElHeight,\n              left: shiftWidth[pos1]()\n            };\n            break;\n        }\n\n        return targetElPos;\n      }\n    };\n  }]);\n\nangular.module('ui-component.base').factory('HoverDelayService', function(){\n    function hoverEventSyncer(duration) {\n        var clear, close, closed, closedTimer, register, timer;\n        timer = null;\n        closed = false;\n        closedTimer = null;\n        register = function(func) {\n            if (closed) {\n                return;\n            }\n            clearTimeout(timer);\n            return timer = setTimeout(func, duration);\n        };\n        clear = function() {\n            return clearTimeout(timer);\n        };\n        close = function(msec) {\n            clearTimeout(timer);\n            clearTimeout(closedTimer);\n            closed = true;\n            return closedTimer = setTimeout((function() {\n                return closed = false;\n            }), msec);\n        };\n        return {\n            register: register,\n            clear: clear,\n            close: close\n        };\n    }\n\n    return {\n        newInstance: function(duration){\n            return hoverEventSyncer(duration);\n        }\n    };\n});\n\n\nangular.module('ui-component.base').directive('uiLoading', function() {\n    return {\n        restrict: 'E',\n        scope: {},\n        template: \"<div class=\\\"ui-loading\\\">\\n<i class=\\\"fa fa-spinner fa-spin pull-left\\\">\\n</i>\\n<h4>{{ text }}</h4>\\n</div>\",\n        link: function(scope, element, attrs) {\n            scope.text = attrs.text;\n            return scope.text != null ? scope.text : scope.text = 'Loading...';\n        }\n    };\n});\n"],"sourceRoot":"/source/"}